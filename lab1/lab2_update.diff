diff --git a/src/executor/Errors.cj b/src/executor/Errors.cj
index 106ff6e..80d19e1 100644
--- a/src/executor/Errors.cj
+++ b/src/executor/Errors.cj
@@ -30,12 +30,20 @@ public enum ErrorCode {
     | WHILE_TYPE_MISMATCH // while 条件表达式的结果不是 `Bool`。
     | BREAK_OUTSIDE_LOOP // 在非循环体内使用 `break`。
     | CONTINUE_OUTSIDE_LOOP // 在非循环体内使用 `continue`.
-    | ASSGIN_IMMUT_VAR // 试图给 `let` 定义的不可变变量赋值。
+    | ASSIGN_IMMUT_VAR // 试图给 `let` 定义的不可变变量赋值。
     | ASSIGN_TYPE_MISMATCH // 试图给变量赋值成不同的类型。
     | UNDEFINED_VAR // 试图使用未定义的变量。
     | DUPLICATED_DEF // 试图在同一静态作用域内定义同名变量。
     | DEF_TYPE_MISMATCH // 变量定义时，赋值的类型与声明的类型不匹配。
     | UNINITIALIZED_VAR // 试图读取未初始化的变量的值。
+    | GLOBAL_NO_INITIALIZER // 全局变量定义缺少初始化表达式。
+    | FUNC_MISSING_RETURN_TYPE // 函数定义中省略了返回类型。
+    | FUNC_MISSING_BODY // 函数定义中缺少函数体。
+    | CALLEE_NOT_FUNCTION // 试图调用一个非函数值。
+    | CALL_ARG_COUNT_MISMATCH // 函数调用时实参个数与形参个数不匹配。
+    | CALL_ARG_TYPE_MISMATCH // 函数调用时实参类型与形参类型不匹配。
+    | FUNC_USE_MUTABLE_NONLOCAL // 试图访问可变非局部变量。
+    | FUNC_RETURN_TYPE_MISMATCH // 函数返回值类型与声明的返回类型不匹配。
 }
 
 public class CjcjRuntimeErrorWithLocation <: Exception {
diff --git a/src/main.cj b/src/main.cj
index 7cef1c4..af69399 100644
--- a/src/main.cj
+++ b/src/main.cj
@@ -3,7 +3,6 @@ package cjcj
 import cjcj.visitor.Program
 import cjcj.parser.*
 import cjcj.scanner.*
-import cjcj.prettyPrinter.YamlPrinter
 import cjcj.executor.Executor
 import std.env.*
 import std.fs.File
@@ -32,9 +31,7 @@ public class Cj {
 
     public static func printAst(source: String): Unit {
         if (let Some(p) <- parseProgram(source)) {
-            let yamlPrinter: YamlPrinter = YamlPrinter()
-            p.yamlPrint(yamlPrinter)
-            println(yamlPrinter.toString())
+            println(p.yamlPrint())
         } else {
             exit(65)
         }
diff --git a/src/parser/DeclParser.cj b/src/parser/DeclParser.cj
index 5abe780..bcc736b 100644
--- a/src/parser/DeclParser.cj
+++ b/src/parser/DeclParser.cj
@@ -42,7 +42,7 @@ internal open class DeclParser {
             if (let Some(funcDef) <- functionDefinition()) {
                 return funcDef
             }
-        } catch (error: ParseError) {
+        } catch (error: ParseError | ConsumeError) {
             helper.synchronize()
         }
         None
@@ -50,7 +50,7 @@ internal open class DeclParser {
 
     private func unnamedParameterList(): ArrayList<FuncParam> {
         let parameters: ArrayList<FuncParam> = ArrayList()
-        let start: (Token, Int64) = (helper.previous(), helper.current - 1)
+        let start: (Token, Int64) = helper.previousNonNLTokenWithIndex()
         if (helper.check(TK.IDENTIFIER)) {
             do {
                 if (helper.check(TK.IDENTIFIER)) {
@@ -122,20 +122,21 @@ internal open class DeclParser {
             return ArrayList()
         }
         helper.consume(TK.LPAREN, "Expect '(' before function parameters", helper.current)
-        let start: (Token, Int64) = (helper.previous(), helper.current - 1)
+        let start: (Token, Int64) = helper.previousNonNLTokenWithIndex()
         helper.skipNL()
         let parameters: ArrayList<FuncParam> = ArrayList()
         try {
             parameters.add(all: unnamedParameterList())
             helper.skipNL()
-            helper.consume(TK.RPAREN, "Expect ')' after function parameters", helper.current)
-            helper.skipNL()
-        } catch (e: ConsumeError) {
-            if (helper.check(TK.LCURL)) {
-                reporter.pop()
-                reporter.unclosedDelimiterError(helper.peek(), start[0], start[1], helper.current)
-            } else {
-                helper.synchronizeBlockParenthesis(start[0], start[1])
+            try {
+                helper.consume(TK.RPAREN, "Expect ')' after function parameters", helper.current)
+                helper.skipNL()
+            } catch (e: ConsumeError) {
+                if (helper.check(TK.LCURL)) {
+                    helper.unclosedDelimiterError(helper.peek(), start[0], start[1], helper.current)
+                } else {
+                    helper.synchronizeBlockParenthesis(start[0], start[1])
+                }
             }
         } catch (e: ParseError) {
             helper.synchronizeBlockParenthesis(start[0], start[1])
@@ -195,22 +196,25 @@ internal open class DeclParser {
         try {
             helper.consume(TK.RCURL, "Expect '}' after block.", helper.current)
         } catch (e: ConsumeError) {
-            helper.synchronizeBlockRightCurl(start[0], start[1])
-            reporter.unclosedDelimiterError(helper.peek(), start[0], start[1], helper.current)
+            helper.trySynchronizeBlockRightCurlOrError(helper.peek(), start[0], start[1], helper.current)
         }
         Body(NodeIdManager.nextId(), decls)
     }
 
     public func classMemberDeclaration(): ?Decl {
         var decl: ?Decl = None
-        if (let Some(classInit) <- classInit()) {
-            decl = classInit
-        }
-        if (let Some(variableDeclaration) <- variableDeclaration()) {
-            decl = variableDeclaration
-        }
-        if (let Some(functionDefinition) <- functionDefinition()) {
-            decl = functionDefinition
+        try {
+            if (let Some(classInit) <- classInit()) {
+                decl = classInit
+            }
+            if (let Some(variableDeclaration) <- variableDeclaration()) {
+                decl = variableDeclaration
+            }
+            if (let Some(functionDefinition) <- functionDefinition()) {
+                decl = functionDefinition
+            }
+        } catch (e: ParseError | ConsumeError) {
+            helper.synchronize()
         }
         decl
     }
@@ -302,8 +306,7 @@ internal open class DeclParser {
         try {
             helper.consume(TK.RCURL, "Expect '}' after block.", helper.current)
         } catch (e: ConsumeError) {
-            helper.synchronizeBlockRightCurl(start[0], start[1])
-            reporter.unclosedDelimiterError(helper.peek(), start[0], start[1], helper.current)
+            helper.trySynchronizeBlockRightCurlOrError(helper.peek(), start[0], start[1], helper.current)
         }
 
         println("Error is found in body : ${reporter.empty}")
@@ -312,11 +315,14 @@ internal open class DeclParser {
     }
 
     private func interfaceMemberDeclaration(): ?Decl {
-        if (let Some(functionDefinition) <- functionDefinition()) {
-            functionDefinition
-        } else {
-            None
+        try {
+            if (let Some(functionDefinition) <- functionDefinition()) {
+                functionDefinition
+            }
+        } catch (e: ParseError | ConsumeError) {
+            helper.synchronize()
         }
+        None
     }
 
     private func superClass(): TypeNode {
@@ -329,24 +335,35 @@ internal open class DeclParser {
     }
 
     private func nodeType(id: NodeId, typeParameterName: ?Token): TypeNode {
-        if (helper.matches(TokenKind.LPAREN)) {
+        if (helper.matches(TK.LPAREN)) {
             // Function type, and maybe Tuple type in the future
             let paramTypes = ArrayList<TypeNode>()
-            if (!helper.matches(TokenKind.RPAREN)) {
+            if (!helper.matches(TK.RPAREN)) {
                 while (true) {
+                    helper.skipNL()
                     paramTypes.add(nodeType(NodeIdManager.nextId(), None))
-                    if (helper.matches(TokenKind.RPAREN)) {
+                    helper.skipNL()
+                    if (helper.matches(TK.RPAREN)) {
                         break
-                    } else if (!helper.matches(TokenKind.COMMA)) {
+                    } else if (!helper.matches(TK.COMMA)) {
                         helper.error(helper.peek(),
-                            "Expected ',' or ')' in function type, found '\u{001b}[31m${helper.peek().value}\u{001b}[0m'",
+                            "Expected new line, ',' or ')' in function type, found '\u{001b}[31m${helper.peek().value}\u{001b}[0m'",
                             helper.current)
                     }
                 }
             }
-            helper.consume(TokenKind.ARROW, "Expect '->' in function type", helper.current)
+            helper.skipNL()
+            helper.consume(TK.ARROW, "Expect '->' in function type", helper.current)
+            helper.skipNL()
             let returnType = nodeType(NodeIdManager.nextId(), None)
             FuncType(id, typeParameterName, paramTypes, returnType)
+        } else if (helper.matches(TK.UNIT_LITERAL)) {
+            // Function type with no parameters
+            helper.skipNL()
+            helper.consume(TK.ARROW, "Expect '->' in function type", helper.current)
+            helper.skipNL()
+            let returnType = nodeType(NodeIdManager.nextId(), None)
+            FuncType(id, typeParameterName, ArrayList<TypeNode>(), returnType)
         } else {
             let typeName = helper.advance()
             let typeParamName = typeParameterName.getOrDefault({=> typeName})
@@ -444,16 +461,18 @@ internal open class DeclParser {
 
         var nodes: ArrayList<Node> = ArrayList()
         helper.consume(TK.LCURL, "Expect '{' before block.", helper.current)
-        let start: (Token, Int64) = (helper.peek(), helper.current)
+        let start: (Token, Int64) = (helper.previous(), helper.current - 1)
         try {
             nodes = expressionOrDeclarations()
             helper.endStar()
             helper.consume(TK.RCURL, "Expect '}' after block.", helper.current)
-        } catch (e: ParseError) {
-            helper.synchronizeBlockRightCurl(start[0], start[1])
-            reporter.unclosedDelimiterError(helper.peek(), start[0], start[1], helper.current)
-        } catch (e: ConsumeError) {
-            reporter.unclosedDelimiterError(helper.peek(), start[0], start[1], helper.current)
+        } catch (e: ParseError | ConsumeError) {
+            // ParserError comes from expressionOrDeclaration(),
+            // and ConsumeError comes from helper.consume(...),
+            // both indicating something invalid appears in the block,
+            // which means the block is either missing a '}',
+            // or containing TLDs.
+            helper.trySynchronizeBlockRightCurlOrError(helper.peek(), start[0], start[1], helper.current)
         }
         Block(NodeIdManager.nextId(), nodes)
     }
@@ -482,23 +501,18 @@ internal open class DeclParser {
     }
 
     private func expressionOrDeclaration(): ?Node {
-        try {
-            if (let Some(decl) <- declaration()) {
-                return decl
-            }
-            if (let Some(expr) <- expression()) {
-                return expr
-            }
-            if (helper.matches(TKH.END) || helper.check(TK.RCURL)) {
-                return None
-            }
-            throw helper.error(helper.peek(),
-                "Expected expression or declaration inside block, found '\u{001b}[31m${helper.peek().value}\u{001b}[0m'",
-                helper.current)
-        } catch (e: ParseError) {
-            helper.synchronize()
+        if (let Some(decl) <- declaration()) {
+            return decl
         }
-        None
+        if (let Some(expr) <- expression()) {
+            return expr
+        }
+        if (helper.matches(TKH.END) || helper.check(TK.RCURL)) {
+            return None
+        }
+        throw helper.error(helper.peek(),
+            "Expected expression or declaration inside block, found '\u{001b}[31m${helper.peek().value}\u{001b}[0m'",
+            helper.current)
     }
 
     private func whileExpr(): ?Expr {
@@ -679,11 +693,13 @@ internal open class DeclParser {
                         helper.skipNL()
                     } while (helper.matches(TK.COMMA))
                 }
-                helper.consume(TK.RPAREN, "Expect ')' after arguments.", helper.current)
+                try {
+                    helper.consume(TK.RPAREN, "Expect ')' after arguments.", helper.current)
+                } catch (e: ConsumeError) {
+                    helper.unclosedDelimiterError(helper.peek(), start[0], start[1], helper.current)
+                }
             } catch (e: ParseError) {
                 helper.synchronizeCallParenthesis(start[0], start[1])
-            } catch (e: ConsumeError) {
-                reporter.unclosedDelimiterError(helper.peek(), start[0], start[1], helper.current)
             }
         } else if (!helper.matches(TK.UNIT_LITERAL)) {
             return None
@@ -827,7 +843,7 @@ internal open class DeclParser {
     private func additiveExpression(): ?Expr {
         if (let Some(e) <- multiplicativeExpression()) {
             var expr: Expr = e
-            while (helper.skipNLCompare(TKH.ADDITIVE_OPERATOR)) {
+            while (helper.matches(TK.SUB) || helper.skipNLCompare(TK.ADD)) {
                 let oper: Token = helper.previous()
                 helper.skipNL()
                 let right: Expr = expectExpression(multiplicativeExpression,
@@ -875,6 +891,11 @@ internal open class DeclParser {
         // the problem will be solved.
         if (helper.matches(TKH.PREFIX_UNARY_OPERATOR)) {
             let oper: Token = helper.previous()
+            if (oper.kind == TK.SUB && helper.matches(TK.INTEGER_LITERAL, TK.FLOAT_LITERAL)) {
+                let literal: Token = helper.previous()
+                return LitConstExpr(NodeIdManager.nextId(),
+                    Token(literal.kind, "-" + literal.value, oper.pos))
+            }
             let right: Expr = expectExpression(prefixUnaryExpression,
                 "Expected a postfixExpression after ${oper.value}, found '\u{001b}[31m${helper.peek().value}\u{001b}[0m'")
             return UnaryExpr(NodeIdManager.nextId(), oper, right)
diff --git a/src/parser/ErrorMessage.cj b/src/parser/ErrorMessage.cj
index e859e11..4f2149a 100644
--- a/src/parser/ErrorMessage.cj
+++ b/src/parser/ErrorMessage.cj
@@ -21,31 +21,28 @@ ${spaces} | ${" " * suffixPrefix[0].size}^
 }
 
 public class ErrorUnclosedDelimiter <: BaseErrorMessage {
-    ErrorUnclosedDelimiter(public let line: Int32, public let startIndex: Int64, public let start: String,
-        public let suffixPrefixStart: (String, String), public let currentIndex: Int64, public let current: String,
-        public let suffixPrefixCurrent: (String, String)) {}
+    ErrorUnclosedDelimiter(public let startLine: Int32, public let startIndex: Int64, public let start: String,
+        public let suffixPrefixStart: (String, String), public let currentLine: Int32, public let currentIndex: Int64,
+        public let current: String, public let suffixPrefixCurrent: (String, String), public let end: String) {}
 
     public func toString(): String {
-        let lineStr: String = line.toString()
-        let spaces: String = " " * lineStr.size
-        if (currentIndex - startIndex < 20) {
-            return """
-\u{001b}[31m
-error\u{001b}[0m: unclosed delimiter '${Reporter.redify(start)}'
-${spaces} |
-${lineStr} | ${suffixPrefixStart[0]}${Reporter
-                .redify(start)} ${suffixPrefixStart[1]}
-${spaces} | ${" " * suffixPrefixStart[0].size}^ 
-                """
-        } else {
-            return """
+        let startLineStr: String = startLine.toString()
+        let startSpaces: String = " " * startLineStr.size
+        let currentLineStr: String = currentLine.toString()
+        let currentSpaces: String = " " * currentLineStr.size
+        return """
 \u{001b}[31m
-error\u{001b}[0m: unclosed delimiter '${Reporter.redify(start)}'
-${spaces} |
-${lineStr} | ${suffixPrefixStart[0]}${Reporter
-                .redify(start)} ${suffixPrefixStart[1]}
-${spaces} | ${" " * suffixPrefixStart[0].size}^
-                """
-        }
+error\u{001b}[0m: unclosed delimiter: '${Reporter.redify(start)}'
+${startSpaces} |
+${startLineStr} | ${suffixPrefixStart[0]}${Reporter
+            .redify(start)} ${suffixPrefixStart[1]}
+${startSpaces} | ${" " * suffixPrefixStart[0].size}^
+\u{001b}[36minfo\u{001b}[0m: reached '${Reporter
+            .redify(current)}' without closing '${Reporter.redify(end)}'
+${currentSpaces} |
+${currentLineStr} | ${suffixPrefixCurrent[0]}${Reporter
+            .redify(current)} ${suffixPrefixCurrent[1]}
+${currentSpaces} | ${" " * suffixPrefixCurrent[0].size}^
+            """
     }
 }
diff --git a/src/parser/Parser.cj b/src/parser/Parser.cj
index ad51cac..1f87e57 100644
--- a/src/parser/Parser.cj
+++ b/src/parser/Parser.cj
@@ -55,7 +55,15 @@ public class Parser {
             } else {
                 return None
             }
-        } catch (_) {
+        } catch (_: FinalError) {
+            return None
+        } catch (e: Exception) {
+            let builder = StringBuilder()
+            for (elem in e.getStackTrace()) {
+                builder.append("\n\tat ${elem.declaringClass}::${elem.methodName}(${elem.fileName}:${elem.lineNumber})")
+            }
+            parserHelper.error(parserHelper.peek(),
+                "Internal error during parsing:\n${e.toString()}${builder.toString()}", parserHelper.current)
             return None
         }
     }
diff --git a/src/parser/ParserHelper.cj b/src/parser/ParserHelper.cj
index b626329..e11af9e 100644
--- a/src/parser/ParserHelper.cj
+++ b/src/parser/ParserHelper.cj
@@ -100,6 +100,14 @@ class ParserHelper {
         tokens[current_ - 1]
     }
 
+    func previousNonNLTokenWithIndex(): (Token, Int64) {
+        var idx: Int64 = current_ - 1
+        while (idx > 0 && tokens[idx].kind == TokenKind.NL) {
+            idx--
+        }
+        (tokens[idx], idx)
+    }
+
     func next(): Token {
         tokens[current_ + 1]
     }
@@ -132,7 +140,7 @@ class ParserHelper {
         }
     }
 
-    func synchronizeBlockParenthesis(start: Token, current: Int64): ?FinalError {
+    func synchronizeBlockParenthesis(start: Token, current: Int64): Unit {
         var counter: Int64 = 1
         if (!check(TokenKind.LCURL) && !check(TokenKind.COMMA)) {
             do {
@@ -148,35 +156,31 @@ class ParserHelper {
             reporter.pop()
         }
         if (isAtEnd()) {
-            errorFinal(start, "unclosed delimiter: '('", current)
+            reporter.unclosedDelimiterError(peek(), start, current, current_)
         } else if (check(TokenKind.LCURL) && counter > 0) {
-            error(start, "unclosed delimiter: '('", current)
+            reporter.unclosedDelimiterError(peek(), start, current, current_)
         } else if (check(TokenKind.COMMA)) {
             error(tokens[this.current - 1], "Malformed parameter", this.current - 1)
-        } else {
-            None
         }
     }
 
-    func synchronizeBlockRightCurl(start: Token, current: Int64): ?FinalError {
+    func trySynchronizeBlockRightCurl(): Bool {
+        let beforeSynchronization = current_
         var counter: Int64 = 1
-        if (!check(TokenKind.RCURL)) {
-            do {
-                if (peek().kind == TokenKind.LCURL) {
-                    counter++
-                }
-                if (peek().kind == TokenKind.RCURL) {
-                    counter--
-                }
-                advance()
-            } while (!isAtEnd() && counter > 0)
-        }
+        do {
+            if (peek().kind == TokenKind.LCURL) {
+                counter++
+            }
+            if (peek().kind == TokenKind.RCURL) {
+                counter--
+            }
+            advance()
+        } while (!isAtEnd() && counter > 0)
         if (isAtEnd()) {
-            errorFinal(start, "unclosed delimiter: '{'", current)
-        } else if (counter == 0) {
-            return None
+            current_ = beforeSynchronization
+            false
         } else {
-            error(start, "unclosed delimiter: '{'", current)
+            true
         }
     }
 
@@ -232,9 +236,20 @@ class ParserHelper {
         ConsumeError()
     }
 
-    // func unclosedDelimiterError(currentToken: Token, startToken: Token, index: Int64) {
-    //     reporter.unclosedDelimiterError(currentToken, startToken, index)
-    // }
+    func unclosedDelimiterError(currentToken: Token, startToken: Token, startIndex: Int64, currentIndex: Int64) {
+        reporter.pop()
+        reporter.unclosedDelimiterError(currentToken, startToken, startIndex, currentIndex)
+        if (previous().kind == TokenKind.NL) {
+            retreat()
+        }
+    }
+
+    func trySynchronizeBlockRightCurlOrError(currentToken: Token, startToken: Token, startIndex: Int64,
+        currentIndex: Int64) {
+        if (!trySynchronizeBlockRightCurl()) {
+            unclosedDelimiterError(currentToken, startToken, startIndex, currentIndex)
+        }
+    }
 
     func logErrors() {
         reporter.logErrors()
diff --git a/src/parser/Reporter.cj b/src/parser/Reporter.cj
index 1b57b05..957b540 100644
--- a/src/parser/Reporter.cj
+++ b/src/parser/Reporter.cj
@@ -64,11 +64,10 @@ public class Reporter {
     }
 
     func unclosedDelimiterError(currentToken: Token, startToken: Token, startIndex: Int64, currentIndex: Int64) {
-        pop()
-        pop()
         errors.add(
-            ErrorUnclosedDelimiter(currentToken.pos.line, startIndex, startToken.value, getSuffixPrefix(startIndex),
-                currentIndex, currentToken.value, getSuffixPrefix(currentIndex)))
+            ErrorUnclosedDelimiter(startToken.pos.line, startIndex, startToken.value, getSuffixPrefix(startIndex),
+                currentToken.pos.line, currentIndex, currentToken.value, getSuffixPrefix(currentIndex),
+                getEndToken(startToken.kind)))
     }
 
     public static func redify(str: String) {
@@ -89,3 +88,12 @@ Failed to parse program.
         }
     }
 }
+
+private func getEndToken(startKind: TokenKind): String {
+    match (startKind) {
+        case TokenKind.LPAREN => ")"
+        case TokenKind.LCURL => "}"
+        case TokenKind.LSQUARE => "]"
+        case _ => throw Exception("Invalid start token kind for delimiter")
+    }
+}
diff --git a/src/prettyPrinter/YamlPrinter.cj b/src/prettyPrinter/YamlPrinter.cj
index 0fb1a5b..40f823b 100644
--- a/src/prettyPrinter/YamlPrinter.cj
+++ b/src/prettyPrinter/YamlPrinter.cj
@@ -1,5 +1,8 @@
 package cjcj.prettyPrinter
 
+import cjcj.scanner.{Token, TokenKind}
+import std.ast.Position
+
 public interface YamlPrintable {
     func yamlPrint(printer: YamlPrinter): Unit
 }
@@ -67,9 +70,38 @@ public class YamlPrinter {
         )
     }
 
-    public func print(key: String, value: ToString): Unit {
+    public func print(key: String, token: Token): Unit {
+        print(key, token.value)
+        printPosition(token.pos)
+    }
+
+    public func print(key: String, value: ToString, enforceQuoting!: Bool = false): Unit {
+        let valueString = value.toString()
+        let formattedValue = if (!enforceQuoting && valueString.runes().all({r => r.isAsciiNumberOrLetter()})) {
+            valueString
+        } else if (valueString.contains("\n") || valueString.contains("\t") || valueString.contains("'")) {
+            '\"${valueString.replace("\\", "\\\\").replace("\n", "\\n").replace("\t", "\\t").replace('"', '\\"')}\"'
+        } else {
+            "'${valueString}'"
+        }
+        printRaw(key, formattedValue)
+    }
+
+    public func printLiteral(key: String, literal: Token): Unit {
+        match (literal.kind) {
+            case TokenKind.STRING_LITERAL => print(key, literal.value, enforceQuoting: true)
+            case _ => print(key, literal.value)
+        }
+        printPosition(literal.pos)
+    }
+
+    private func printRaw(key: String, rawValue: String): Unit {
         printlnIfNeeded()
-        printer.append(key + ": " + value.toString())
+        printer.append("${key}: ${rawValue}")
+    }
+
+    private func printPosition(pos: Position): Unit {
+        printer.append(" # Position: ${pos.line}:${pos.column}")
     }
 
     public func toString(): String {
diff --git a/src/scanner/Scanner.cj b/src/scanner/Scanner.cj
index b213d59..835398a 100644
--- a/src/scanner/Scanner.cj
+++ b/src/scanner/Scanner.cj
@@ -112,9 +112,7 @@ public class Scanner {
             case ',' => addToken(TokenKind.COMMA)
             case '.' => addToken(TokenKind.DOT)
 
-            case ';' =>
-                addToken(TokenKind.SEMI)
-                if (matches(r'\n')) {}
+            case ';' => addToken(TokenKind.SEMI)
 
             case '^' => addToken(TokenKind.BITXOR)
             case '~' => addToken(TokenKind.BITNOT)
@@ -122,7 +120,7 @@ public class Scanner {
             case '#' => addToken(TokenKind.HASH)
             case '?' => addToken(TokenKind.QUEST)
             case '_' =>
-                if (isAlpha(peekNext())) {
+                if (isAlpha(peek())) {
                     identifier()
                 } else {
                     addToken(TokenKind.WILDCARD)
@@ -261,7 +259,9 @@ public class Scanner {
                         skipSpace()
                     }
                 }
-                addToken(TokenKind.NL, "\\n".toRuneArray())
+                if (lastTokenKind() != TokenKind.SEMI) {
+                    addToken(TokenKind.NL, "\\n".toRuneArray())
+                }
                 return
 
             case '\r' =>
@@ -275,7 +275,9 @@ public class Scanner {
                         skipSpace()
                     }
                 }
-                addToken(TokenKind.NL, "\\n".toRuneArray())
+                if (lastTokenKind() != TokenKind.SEMI) {
+                    addToken(TokenKind.NL, "\\n".toRuneArray())
+                }
                 return
 
             case ' ' => return
@@ -430,6 +432,14 @@ public class Scanner {
     private func addToken(typ: TokenKind, value: Array<Rune>) {
         tokens.add(Token(typ, String(value), Position(0, line, column)))
     }
+
+    private func lastTokenKind(): TokenKind {
+        if (tokens.isEmpty()) {
+            TokenKind.ILLEGAL
+        } else {
+            tokens[tokens.size - 1].kind
+        }
+    }
 }
 
 @When[os == "Windows"]
diff --git a/src/scanner/TokenKind.cj b/src/scanner/TokenKind.cj
index a9842e2..837cbd6 100644
--- a/src/scanner/TokenKind.cj
+++ b/src/scanner/TokenKind.cj
@@ -236,7 +236,7 @@ public enum TokenKind <: ToString {
     | /*  "()"               */
         ARROW
     | /*  "->"               */
-    ILLEGAL
+        ILLEGAL
 
     public func toString(): String {
         return match (this) {
diff --git a/src/test/Parser_test.cj b/src/test/Parser_test.cj
index e4db63d..c142128 100644
--- a/src/test/Parser_test.cj
+++ b/src/test/Parser_test.cj
@@ -5,6 +5,8 @@ import cjcj.parser
 import cjcj.scanner.*
 import std.env.*
 import std.collection.ArrayList
+import std.unittest.*
+import std.unittest.testmacro.*
 
 @Test
 class ParserTests {
diff --git a/src/visitor/Decls.cj b/src/visitor/Decls.cj
index 609de50..553ccc6 100644
--- a/src/visitor/Decls.cj
+++ b/src/visitor/Decls.cj
@@ -89,10 +89,10 @@ public abstract class Decl <: Node & Equatable<Decl> {
 
     public open override func yamlPrint(printer: YamlPrinter): Unit {
         if (keyword.kind != TokenKind.ILLEGAL) {
-            printer.print("keyword", keyword.value)
+            printer.print("keyword", keyword)
         }
         if (keyword.kind != TokenKind.ILLEGAL) {
-            printer.print("identifier", identifier.value)
+            printer.print("identifier", identifier)
         }
         printer.printOptionalObject("declType", declType)
     }
@@ -248,6 +248,7 @@ public class FuncParam <: Decl {
     public override func yamlPrint(printer: YamlPrinter): Unit {
         printer.print("type", "FuncParam")
         super.yamlPrint(printer)
+        printer.print("name", name)
         printer.printObject("paramType", paramType)
     }
 
diff --git a/src/visitor/Exprs.cj b/src/visitor/Exprs.cj
index 11d1397..506281b 100644
--- a/src/visitor/Exprs.cj
+++ b/src/visitor/Exprs.cj
@@ -57,7 +57,7 @@ public class BinaryExpr <: Expr {
     public override func yamlPrint(printer: YamlPrinter): Unit {
         printer.print("type", "BinaryExpr")
         printer.printObject("left", left)
-        printer.print("oper", oper.value)
+        printer.print("oper", oper)
         printer.printObject("right", right)
     }
 
@@ -151,7 +151,8 @@ public class LitConstExpr <: Expr {
 
     public override func yamlPrint(printer: YamlPrinter): Unit {
         printer.print("type", "LitConstExpr")
-        printer.print("literal", '"' + literal.value + '"')
+        printer.print("kind", literal.kind)
+        printer.printLiteral("literal", literal)
     }
 
     public mut prop literal: Token {
@@ -189,7 +190,7 @@ public class UnaryExpr <: Expr {
 
     public override func yamlPrint(printer: YamlPrinter): Unit {
         printer.print("type", "UnaryExpr")
-        printer.print("oper", oper.value)
+        printer.print("oper", oper)
         printer.printObject("right", right)
     }
 
@@ -288,7 +289,7 @@ public open class RefExpr <: Expr {
 
     public override func yamlPrint(printer: YamlPrinter): Unit {
         printer.print("type", "RefExpr")
-        printer.print("identifier", identifier.value)
+        printer.print("identifier", identifier)
     }
 }
 
@@ -542,7 +543,7 @@ public class ReturnExpr <: Expr {
     public override func yamlPrint(printer: YamlPrinter): Unit {
         printer.print("type", "ReturnExpr")
         printer.printOptionalObject("expr", expr)
-        printer.print("keyword", keyword.value)
+        printer.print("keyword", keyword)
     }
 
     public mut prop expr: ?Expr {
@@ -586,7 +587,7 @@ public class JumpExpr <: Expr {
 
     public override func yamlPrint(printer: YamlPrinter): Unit {
         printer.print("type", "JumpExpr")
-        printer.print("keyword", keyword.value)
+        printer.print("keyword", keyword)
     }
 
     public mut prop keyword: Token {
@@ -621,7 +622,7 @@ public open class MemberAccess <: Expr {
     public override func yamlPrint(printer: YamlPrinter): Unit {
         printer.print("type", "MemberAccess")
         printer.printObject("baseExpr", baseExpr)
-        printer.print("field", field.value)
+        printer.print("field", field)
     }
 
     public open override func traverse<R>(v: Visitor<R>): R {
@@ -665,7 +666,7 @@ public class PrimitiveTypeExpr <: Expr {
 
     public override func yamlPrint(printer: YamlPrinter): Unit {
         printer.print("type", "PrimitiveTypeExpr")
-        printer.print("keyword", keyword.value)
+        printer.print("keyword", keyword)
     }
 
     public override func traverse<R>(v: Visitor<R>): R {
@@ -700,7 +701,7 @@ public class ThisSuperExpr <: Expr {
 
     public override func yamlPrint(printer: YamlPrinter): Unit {
         printer.print("type", "ThisSuperExpr")
-        printer.print("keyword", keyword.value)
+        printer.print("keyword", keyword)
     }
 
     public override func traverse<R>(v: Visitor<R>): R {
diff --git a/src/visitor/Node.cj b/src/visitor/Node.cj
index 77940f4..f7aefdf 100644
--- a/src/visitor/Node.cj
+++ b/src/visitor/Node.cj
@@ -38,6 +38,18 @@ public abstract class Node <: Hashable & Equatable<Node> & YamlPrintable {
 
     public func yamlPrint(printer: YamlPrinter): Unit
 
+    public func prettyPrint(): String {
+        let printer: PrettyPrinter = PrettyPrinter()
+        prettyPrint(printer)
+        return printer.toString()
+    }
+
+    public func yamlPrint(): String {
+        let printer: YamlPrinter = YamlPrinter()
+        yamlPrint(printer)
+        return printer.toString()
+    }
+
     public mut prop id: NodeId {
         get() {
             id_
diff --git a/src/visitor/TypeNodes.cj b/src/visitor/TypeNodes.cj
index cefdadb..f7317b9 100644
--- a/src/visitor/TypeNodes.cj
+++ b/src/visitor/TypeNodes.cj
@@ -35,8 +35,8 @@ public open class TypeNode <: Node {
     }
 
     public open override func yamlPrint(printer: YamlPrinter): Unit {
-        printer.print("typeParameterName", typeParameterName.value)
-        printer.print("typeName", typeName.value)
+        printer.print("typeParameterName", typeParameterName)
+        printer.print("typeName", typeName)
     }
 
     public mut prop typeParameterName: Token {
@@ -157,5 +157,4 @@ public class FuncType <: TypeNode {
         printer.printList("paramTypes", paramTypes_)
         printer.printObject("returnType", returnType_)
     }
-
 }
